<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mirror's Echo - Live Stream</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .split-viewer {
            display: flex;
            height: 100vh;
            width: 100vw;
            background: #000;
        }

        .stream-panel {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            border: 2px solid #333;
        }

        .stream-panel.left {
            border-right: 1px solid #333;
        }

        .stream-panel.right {
            border-left: 1px solid #333;
        }

        .stream-header {
            padding: 1rem;
            background: #1a1a1a;
            border-bottom: 2px solid #333;
            text-align: center;
        }

        .stream-header h2 {
            font-family: 'Futura', 'Century Gothic', sans-serif;
            font-size: 1.5rem;
            margin: 0;
            color: #ffffff;
        }

        .stream-header .status {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .stream-header .status.live {
            color: #00ff00;
        }

        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .popout-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            padding: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: breathe 3s ease-in-out infinite;
        }

        .popout-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ffffff;
            transform: scale(1.1);
            animation: none;
        }

        .popout-button::before {
            content: "â¤¢";
        }

        @keyframes breathe {
            0%, 100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        .fullscreen-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 1000;
            flex-direction: column;
        }

        .fullscreen-overlay.active {
            display: flex;
        }

        .fullscreen-header {
            padding: 1.5rem 2rem;
            background: rgba(26, 26, 26, 0.98);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #444;
            backdrop-filter: blur(20px);
        }

        .fullscreen-header h2 {
            font-family: 'Futura', 'Century Gothic', sans-serif;
            color: #ffffff;
            margin: 0;
            font-size: 1.8rem;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .popout-external-button {
            padding: 10px 24px;
            background: transparent;
            border: 2px solid #00ff00;
            border-radius: 8px;
            color: #00ff00;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .popout-external-button:hover {
            background: #00ff00;
            color: #000;
            transform: translateY(-2px);
        }

        .close-button {
            padding: 10px 24px;
            background: transparent;
            border: 2px solid #ffffff;
            border-radius: 8px;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .close-button:hover {
            background: #ffffff;
            color: #000;
            transform: translateY(-2px);
        }

        .fullscreen-video {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .fullscreen-video video {
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .connection-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 8px;
            color: #666;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .connection-indicator.connected {
            border-color: #00ff00;
            color: #00ff00;
        }

        @media (max-width: 768px) {
            .split-viewer {
                flex-direction: column;
            }

            .stream-panel.left {
                border-right: none;
                border-bottom: 1px solid #333;
            }

            .stream-panel.right {
                border-left: none;
                border-top: 1px solid #333;
            }
        }
    </style>
</head>
<body>
    <div class="split-viewer">
        <!-- LEFT: Remote Person's Incoming Webcam -->
        <div class="stream-panel left">
            <div class="stream-header">
                <h2>Remote Input</h2>
                <div class="status" id="inputStatus">âšª Waiting for stream...</div>
            </div>
            <div class="video-container">
                <video id="inputVideo" autoplay playsinline></video>
                <div class="connection-indicator" id="inputIndicator">Connecting...</div>
            </div>
        </div>

        <!-- RIGHT: Your Processed Output -->
        <div class="stream-panel right">
            <div class="stream-header">
                <h2>Your Processed Output</h2>
                <div class="status" id="outputStatus">âšª Waiting for stream...</div>
            </div>
            <div class="video-container">
                <video id="outputVideo" autoplay playsinline></video>
                <button class="popout-button" id="popoutBtn" title="Open in new window"></button>
                <div class="connection-indicator" id="outputIndicator">Connecting...</div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Overlay -->
    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="fullscreen-header">
            <h2>Your Output - Fullscreen</h2>
            <div class="header-controls">
                <button class="popout-external-button" id="popoutWindowBtn">â¤¢ Pop Out to Window</button>
                <button class="close-button" id="closeBtn">âœ• Close</button>
            </div>
        </div>
        <div class="fullscreen-video">
            <video id="fullscreenVideo" autoplay playsinline></video>
        </div>
    </div>

    <script>
        const inputVideo = document.getElementById('inputVideo');
        const outputVideo = document.getElementById('outputVideo');
        const fullscreenVideo = document.getElementById('fullscreenVideo');
        const popoutBtn = document.getElementById('popoutBtn');
        const popoutWindowBtn = document.getElementById('popoutWindowBtn');
        const closeBtn = document.getElementById('closeBtn');
        const fullscreenOverlay = document.getElementById('fullscreenOverlay');
        
        const inputStatus = document.getElementById('inputStatus');
        const outputStatus = document.getElementById('outputStatus');
        const inputIndicator = document.getElementById('inputIndicator');
        const outputIndicator = document.getElementById('outputIndicator');

        let peerConnection = null;
        let signalingSocket = null;

        const rtcConfig = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        const SIGNALING_SERVER_URL = 'wss://marvelous-blessing-production-4059.up.railway.app/ws';

        // Auto-connect on load
        window.addEventListener('DOMContentLoaded', connect);

        async function connect() {
            try {
                updateStatus('Connecting to stream...', false);

                signalingSocket = new WebSocket(SIGNALING_SERVER_URL);

                signalingSocket.onopen = () => {
                    console.log('âœ… Connected to signaling server');
                    updateStatus('Connected - Waiting for publisher...', false);
                    signalingSocket.send(JSON.stringify({ type: 'join' }));
                };

                signalingSocket.onmessage = handleSignalingMessage;

                signalingSocket.onerror = (error) => {
                    console.error('âŒ WebSocket error:', error);
                    updateStatus('Connection failed', true);
                };

                signalingSocket.onclose = () => {
                    console.log('Disconnected from signaling server');
                    updateStatus('Disconnected - Reconnecting...', true);
                    setTimeout(connect, 3000);
                };

            } catch (error) {
                console.error('Error connecting:', error);
                updateStatus('Error: ' + error.message, true);
            }
        }

        async function handleSignalingMessage(event) {
            const message = JSON.parse(event.data);
            console.log('ðŸ“¨ Received:', message.type);

            switch (message.type) {
                case 'offer':
                    await createPeerConnection();
                    await handleOffer(message.offer);
                    break;
                case 'answer':
                    await handleAnswer(message.answer);
                    break;
                case 'candidate':
                    await handleCandidate(message.candidate);
                    break;
                case 'bye':
                    handleRemoteHangup();
                    break;
            }
        }

        async function createPeerConnection() {
            if (peerConnection) return;

            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.ontrack = (event) => {
                console.log('ðŸŽ¥ Received remote track');
                
                // Set both videos to same stream (TD output)
                if (outputVideo.srcObject !== event.streams[0]) {
                    outputVideo.srcObject = event.streams[0];
                    fullscreenVideo.srcObject = event.streams[0];
                    
                    // For now, mirror to input side (you can change this)
                    inputVideo.srcObject = event.streams[0];
                    
                    updateStatus('ðŸŽ¥ Live!', false, true);
                }
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        type: 'candidate',
                        candidate: event.candidate
                    }));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                
                if (peerConnection.connectionState === 'connected') {
                    updateStatus('ðŸŽ¥ Live!', false, true);
                } else if (peerConnection.connectionState === 'disconnected' || 
                           peerConnection.connectionState === 'failed') {
                    updateStatus('Connection lost', true);
                }
            };
        }

        async function handleOffer(offer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                signalingSocket.send(JSON.stringify({
                    type: 'answer',
                    answer: answer
                }));
            } catch (error) {
                console.error('Error handling offer:', error);
                updateStatus('Connection error', true);
            }
        }

        async function handleAnswer(answer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            } catch (error) {
                console.error('Error handling answer:', error);
            }
        }

        async function handleCandidate(candidate) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
            } catch (error) {
                console.error('Error handling ICE candidate:', error);
            }
        }

        function handleRemoteHangup() {
            console.log('Remote peer disconnected');

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            inputVideo.srcObject = null;
            outputVideo.srcObject = null;
            fullscreenVideo.srcObject = null;
            
            updateStatus('Publisher disconnected', true);
        }

        function updateStatus(message, isError, isLive = false) {
            console.log(message);
            
            const emoji = isLive ? 'ðŸ”´' : isError ? 'âš ï¸' : 'âšª';
            
            inputStatus.textContent = `${emoji} ${message}`;
            outputStatus.textContent = `${emoji} ${message}`;
            
            inputIndicator.textContent = message;
            outputIndicator.textContent = message;
            
            if (isLive) {
                inputIndicator.classList.add('connected');
                outputIndicator.classList.add('connected');
            } else {
                inputIndicator.classList.remove('connected');
                outputIndicator.classList.remove('connected');
            }
        }

        // Fullscreen controls
        popoutBtn.addEventListener('click', () => {
            fullscreenOverlay.classList.add('active');
        });

        closeBtn.addEventListener('click', () => {
            fullscreenOverlay.classList.remove('active');
        });

        // Pop out to new window
        popoutWindowBtn.addEventListener('click', () => {
            const popupWindow = window.open(
                '', 
                'YourOutputPopout',
                'width=1280,height=720,menubar=no,toolbar=no,location=no,status=no'
            );
            
            if (popupWindow) {
                popupWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Your Output - Pop Out</title>
                        <style>
                            body {
                                margin: 0;
                                padding: 0;
                                background: #000;
                                display: flex;
                                justify-content: center;
                                align-items: center;
                                height: 100vh;
                                overflow: hidden;
                            }
                            video {
                                max-width: 100%;
                                max-height: 100%;
                                object-fit: contain;
                            }
                        </style>
                    </head>
                    <body>
                        <video id="popoutVideo" autoplay playsinline></video>
                        <script>
                            // Sync with parent window's stream
                            const video = document.getElementById('popoutVideo');
                            if (window.opener && window.opener.document.getElementById('outputVideo').srcObject) {
                                video.srcObject = window.opener.document.getElementById('outputVideo').srcObject;
                            }
                            
                            // Update if stream changes
                            const checkStream = setInterval(() => {
                                if (window.opener && window.opener.document.getElementById('outputVideo').srcObject) {
                                    if (video.srcObject !== window.opener.document.getElementById('outputVideo').srcObject) {
                                        video.srcObject = window.opener.document.getElementById('outputVideo').srcObject;
                                    }
                                }
                            }, 1000);
                            
                            window.addEventListener('beforeunload', () => {
                                clearInterval(checkStream);
                            });
                        </script>
                    </body>
                    </html>
                `);
                popupWindow.document.close();
            }
        });

        // ESC to close fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && fullscreenOverlay.classList.contains('active')) {
                fullscreenOverlay.classList.remove('active');
            }
        });
    </script>
</body>
</html>
