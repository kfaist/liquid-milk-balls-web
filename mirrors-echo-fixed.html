<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mirror's Echo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #000;
            color: rgba(255, 255, 255, 0.9);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .header h1 {
            font-size: 1.5rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            opacity: 0.8;
            animation: flicker 3s infinite;
        }
        .header p { 
            opacity: 0.5;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }
        
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 0.8; }
            20%, 24%, 55% { opacity: 0.3; }
            22% { opacity: 0.5; transform: translate(-1px, 0); }
        }
        
        .top-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        
        .btn {
            padding: 0.6rem 2rem;
            font-size: 0.85rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.05em;
            transition: all 0.2s;
        }
        .btn:hover:not(:disabled) {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }
        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .btn.flicker-btn {
            animation: btnFlicker 3s infinite;
        }
        
        @keyframes btnFlicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
                border-color: rgba(255, 255, 255, 0.5);
            }
            20%, 24%, 55% {
                opacity: 0.5;
                border-color: rgba(255, 255, 255, 0.2);
            }
        }
        
        .status-bar {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }
        .status-bar .time {
            font-size: 1.2rem;
            opacity: 0.8;
            letter-spacing: 0.1em;
        }
        .status-bar #status {
            font-size: 0.75rem;
            opacity: 0.5;
            margin-top: 0.5rem;
            letter-spacing: 0.02em;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        @media (max-width: 900px) {
            .video-grid { grid-template-columns: 1fr; }
        }
        
        .video-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 1.5rem;
        }
        .video-panel h3 {
            margin-bottom: 1rem;
            font-size: 0.8rem;
            font-weight: 400;
            opacity: 0.6;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .video-box {
            position: relative;
            aspect-ratio: 16/9;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        
        .fullscreen-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.4rem 0.6rem;
            font-size: 0.7rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        .video-box:hover .fullscreen-btn {
            opacity: 1;
        }
        .video-box video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.75rem;
        }

        .loading-status {
            font-size: 0.7rem;
            color: rgba(255, 105, 180, 0.8);
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            min-height: 1.2rem;
            font-family: 'JetBrains Mono', monospace;
        }
        .loading-status:empty {
            display: none;
        }
        .loading-status .dot {
            animation: blink 1.4s infinite;
        }
        .loading-status .dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-status .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink {
            0%, 20% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Waiting Room Overlay */
        .waiting-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .waiting-overlay h2 {
            font-size: 1.2rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            opacity: 0.8;
        }
        .waiting-overlay p {
            opacity: 0.5;
            margin-bottom: 1rem;
            font-size: 0.8rem;
            text-align: center;
            max-width: 400px;
        }
        .waiting-overlay .wait-status {
            font-size: 0.75rem;
            opacity: 0.4;
            margin-top: 1rem;
        }
        
        /* Raindrop Effects */
        .raindrop {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            will-change: transform, opacity;
            animation: raindrop-crossfade 8s ease-in-out forwards;
        }
        
        @keyframes raindrop-crossfade {
            0% { opacity: 0; transform: scale(0.5); }
            15% { opacity: var(--target-opacity, 0.6); transform: scale(0.9); }
            25% { opacity: var(--target-opacity, 0.6); transform: scale(1); }
            75% { opacity: var(--target-opacity, 0.6); transform: scale(1.05); }
            100% { opacity: 0; transform: scale(1.15); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>THE MIRROR'S ECHO</h1>
            <p>Your camera - Processing - Your reflection transformed</p>
        </div>

        <div class="top-controls">
            <button class="btn flicker-btn" id="connectBtn" onclick="connect()">Connect</button>
            <button class="btn" id="disconnectBtn" onclick="manualDisconnect()" style="display:none;">Disconnect</button>
        </div>

        <div class="status-bar">
            <div class="time" id="timer">00:00</div>
            <div id="status">Click Connect to begin</div>
        </div>

        <div class="video-grid">
            <div class="video-panel">
                <h3>Your Camera (Input)</h3>
                <div class="video-box">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-placeholder" id="localPlaceholder">Camera will appear here</div>
                </div>
            </div>

            <div class="video-panel">
                <h3>Processed Output (Your Reflection)</h3>
                <div class="loading-status" id="loadingStatus"></div>
                <div class="video-box" id="processedBox">
                    <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()">&#x26F6;</button>
                    <video id="processedVideo" autoplay playsinline webkit-playsinline></video>
                    <div class="video-placeholder" id="processedPlaceholder">Processed feed will appear here</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <script>
        // State
        let inputRoom = null;
        let outputRoom = null;
        let localStream = null;
        let startTime = null;
        let timerInterval = null;
        let sessionTimeout = null;
        let isConnected = false;
        let myIdentity = null;
        let waitingInterval = null;

        // Session duration: 11 minutes (full animation range)
        const SESSION_DURATION = 11 * 60 * 1000;
        const RAIN_START = 7 * 60 * 1000;

        // Progressive loading stages
        const loadingStages = [
            "Negotiating with pixels. Please be patient",
            "Killing zombie scripts",
            "Loading Whisper (the slow part)",
            "Loading spaCy NLP",
            "Connecting to LiveKit",
            "Almost there"
        ];
        let loadingInterval = null;
        let loadingStageIndex = 0;

        function startLoadingMessages() {
            const loadingStatus = document.getElementById('loadingStatus');
            loadingStageIndex = 0;

            function showStage() {
                if (loadingStageIndex < loadingStages.length) {
                    const msg = loadingStages[loadingStageIndex];
                    loadingStatus.innerHTML = msg + '<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span>';
                    loadingStageIndex++;
                }
            }

            showStage();
            loadingInterval = setInterval(showStage, 4000);
        }

        function stopLoadingMessages() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
            document.getElementById('loadingStatus').innerHTML = '';
        }

        const localVideo = document.getElementById('localVideo');
        const processedVideo = document.getElementById('processedVideo');
        const localPlaceholder = document.getElementById('localPlaceholder');
        const processedPlaceholder = document.getElementById('processedPlaceholder');
        const statusDiv = document.getElementById('status');
        const timerDiv = document.getElementById('timer');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');

        // ============================================
        // CONNECT
        // ============================================
        async function connect() {
            connectBtn.disabled = true;
            connectBtn.classList.remove('flicker-btn');
            updateStatus('Checking availability...');

            try {
                // Get camera first (so user sees themselves)
                updateStatus('Getting camera...');
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });
                localVideo.srcObject = localStream;
                localPlaceholder.style.display = 'none';

                // Try to get publisher token
                updateStatus('Connecting...');
                const pubResponse = await fetch('/api/publisher-token');
                
                if (pubResponse.status === 409) {
                    // Room is occupied - show waiting room
                    showWaitingRoom();
                    return;
                }
                
                if (!pubResponse.ok) {
                    throw new Error('Failed to get connection token');
                }

                const pubData = await pubResponse.json();
                myIdentity = pubData.identity;

                // Connect to INPUT room
                inputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });
                
                inputRoom.on(LivekitClient.RoomEvent.Disconnected, () => {
                    console.log('Input room disconnected');
                    if (isConnected) forceDisconnect('disconnected');
                });

                await inputRoom.connect(pubData.url, pubData.token);

                // Publish camera
                for (const track of localStream.getTracks()) {
                    await inputRoom.localParticipant.publishTrack(track);
                }

                // Connect to OUTPUT room
                startLoadingMessages();
                const viewResponse = await fetch('/api/processed-viewer-token');
                const viewData = await viewResponse.json();

                outputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });

                outputRoom.on(LivekitClient.RoomEvent.TrackSubscribed, (track, pub, participant) => {
                    if (track.kind === LivekitClient.Track.Kind.Video) {
                        stopLoadingMessages();
                        track.attach(processedVideo);
                        processedPlaceholder.style.display = 'none';
                        updateStatus('Connected - Viewing processed output');
                    }
                });

                outputRoom.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
                    if (track.kind === LivekitClient.Track.Kind.Video) {
                        track.detach(processedVideo);
                        processedPlaceholder.style.display = 'flex';
                        processedPlaceholder.textContent = 'Waiting for processed feed...';
                    }
                });

                await outputRoom.connect(viewData.url, viewData.token);

                // Check for existing video
                outputRoom.remoteParticipants.forEach((participant) => {
                    participant.trackPublications.forEach((pub) => {
                        if (pub.track && pub.track.kind === LivekitClient.Track.Kind.Video) {
                            stopLoadingMessages();
                            pub.track.attach(processedVideo);
                            processedPlaceholder.style.display = 'none';
                        }
                    });
                });

                // SUCCESS - Start session
                isConnected = true;
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
                
                // Set hard 10-minute timeout
                sessionTimeout = setTimeout(() => {
                    endSession();
                }, SESSION_DURATION);

                // Start temporal effects
                runTemporalAnimation();

                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
                updateStatus('Connected - Waiting for processed video...');

            } catch (error) {
                console.error('Connection error:', error);
                updateStatus('Error: ' + error.message);
                cleanupLocal();
                connectBtn.disabled = false;
                connectBtn.classList.add('flicker-btn');
            }
        }

        // ============================================
        // WAITING ROOM
        // ============================================
        function showWaitingRoom() {
            const overlay = document.createElement('div');
            overlay.className = 'waiting-overlay';
            overlay.id = 'waitingOverlay';
            overlay.innerHTML = `
                <h2>The Mirror's Echo is Currently in Use</h2>
                <p>Another viewer is experiencing the installation. You'll be connected automatically when the room becomes available.</p>
                <div class="wait-status" id="waitStatus">Checking availability...</div>
                <button class="btn" style="margin-top: 2rem;" onclick="cancelWaiting()">Cancel</button>
            `;
            document.body.appendChild(overlay);
            
            // Poll every 5 seconds
            waitingInterval = setInterval(checkAndConnect, 5000);
        }

        async function checkAndConnect() {
            const waitStatus = document.getElementById('waitStatus');
            if (waitStatus) waitStatus.textContent = 'Checking availability...';
            
            try {
                const pubResponse = await fetch('/api/publisher-token');
                
                if (pubResponse.status === 409) {
                    if (waitStatus) waitStatus.textContent = 'Still waiting... another session is active.';
                    return;
                }
                
                if (pubResponse.ok) {
                    // Room is available! Remove waiting overlay and connect
                    clearInterval(waitingInterval);
                    waitingInterval = null;
                    
                    const overlay = document.getElementById('waitingOverlay');
                    if (overlay) overlay.remove();
                    
                    const pubData = await pubResponse.json();
                    myIdentity = pubData.identity;
                    
                    // Connect to room
                    inputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });
                    
                    inputRoom.on(LivekitClient.RoomEvent.Disconnected, () => {
                        if (isConnected) forceDisconnect('disconnected');
                    });

                    await inputRoom.connect(pubData.url, pubData.token);

                    for (const track of localStream.getTracks()) {
                        await inputRoom.localParticipant.publishTrack(track);
                    }

                    // Output room
                    const viewResponse = await fetch('/api/processed-viewer-token');
                    const viewData = await viewResponse.json();

                    outputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });

                    outputRoom.on(LivekitClient.RoomEvent.TrackSubscribed, (track, pub, participant) => {
                        if (track.kind === LivekitClient.Track.Kind.Video) {
                            track.attach(processedVideo);
                            processedPlaceholder.style.display = 'none';
                            updateStatus('Connected - Viewing processed output');
                        }
                    });

                    await outputRoom.connect(viewData.url, viewData.token);

                    outputRoom.remoteParticipants.forEach((participant) => {
                        participant.trackPublications.forEach((pub) => {
                            if (pub.track && pub.track.kind === LivekitClient.Track.Kind.Video) {
                                pub.track.attach(processedVideo);
                                processedPlaceholder.style.display = 'none';
                            }
                        });
                    });

                    isConnected = true;
                    startTime = Date.now();
                    timerInterval = setInterval(updateTimer, 1000);
                    sessionTimeout = setTimeout(() => endSession(), SESSION_DURATION);
                    runTemporalAnimation();

                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-block';
                    updateStatus('Connected!');
                }
            } catch (error) {
                console.error('Check error:', error);
                if (waitStatus) waitStatus.textContent = 'Error checking... will retry.';
            }
        }

        function cancelWaiting() {
            if (waitingInterval) {
                clearInterval(waitingInterval);
                waitingInterval = null;
            }
            const overlay = document.getElementById('waitingOverlay');
            if (overlay) overlay.remove();
            
            cleanupLocal();
            connectBtn.disabled = false;
            connectBtn.classList.add('flicker-btn');
            updateStatus('Cancelled');
        }

        // ============================================
        // DISCONNECT FUNCTIONS
        // ============================================
        
        // Manual disconnect (user clicked button) - redirect to licensing
        async function manualDisconnect() {
            await forceDisconnect('manual');
            window.location.href = '/licensing.html?session=complete';
        }

        // Force disconnect (timeout, page close, etc)
        async function forceDisconnect(reason) {
            console.log('Force disconnect, reason:', reason);
            isConnected = false;
            
            // Clear timers
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
            if (sessionTimeout) { clearTimeout(sessionTimeout); sessionTimeout = null; }

            // Tell server to kick us (ensures cleanup even if WebSocket dies)
            if (myIdentity) {
                try {
                    navigator.sendBeacon('/api/disconnect', JSON.stringify({ identity: myIdentity }));
                } catch (e) {
                    // Fallback
                    fetch('/api/disconnect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ identity: myIdentity }),
                        keepalive: true
                    }).catch(() => {});
                }
            }

            // Disconnect rooms
            if (inputRoom) { 
                try { await inputRoom.disconnect(); } catch(e) {}
                inputRoom = null; 
            }
            if (outputRoom) { 
                try { await outputRoom.disconnect(); } catch(e) {}
                outputRoom = null; 
            }
            
            cleanupLocal();
            myIdentity = null;
        }

        // Cleanup local resources
        function cleanupLocal() {
            stopLoadingMessages();
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            processedVideo.srcObject = null;
            localPlaceholder.style.display = 'flex';
            processedPlaceholder.style.display = 'flex';
            processedPlaceholder.textContent = 'Processed feed will appear here';
            startTime = null;
        }

        // End session (10 min timeout)
        function endSession() {
            console.log('Session ended - 10 minutes');
            forceDisconnect('timeout');
            
            // Redirect to licensing page
            window.location.href = '/licensing.html?session=complete';
        }

        // ============================================
        // PAGE CLOSE/HIDE HANDLERS
        // ============================================
        window.addEventListener('beforeunload', (e) => {
            if (isConnected) {
                forceDisconnect('beforeunload');
            }
        });
        
        window.addEventListener('pagehide', () => {
            if (isConnected) {
                forceDisconnect('pagehide');
            }
        });
        
        window.addEventListener('unload', () => {
            if (isConnected) {
                forceDisconnect('unload');
            }
        });
        
        // Tab visibility disconnect REMOVED - users stay for full 10-min experience

        // ============================================
        // UTILITIES
        // ============================================
        function updateStatus(msg) {
            statusDiv.textContent = msg;
            console.log('[Mirror] ' + msg);
        }

        function updateTimer() {
            if (!startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const min = Math.floor(elapsed / 60);
            const sec = elapsed % 60;
            timerDiv.textContent = `${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
        }
        
        function toggleFullscreen() {
            const videoBox = document.getElementById('processedBox');
            const video = document.getElementById('processedVideo');
            
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            
            if (!isFullscreen) {
                const element = video.srcObject ? video : videoBox;
                if (element.requestFullscreen) element.requestFullscreen();
                else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen();
                else if (element.webkitEnterFullscreen) element.webkitEnterFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }
        
        // ============================================
        // TEMPORAL EFFECTS (Rainbow raindrops)
        // ============================================
        let animationRunning = false;
        
        const colors = [
            'rgba(255, 105, 180, 0.9)', 'rgba(138, 43, 226, 0.9)',
            'rgba(75, 0, 130, 0.9)', 'rgba(0, 191, 255, 0.9)',
            'rgba(127, 255, 212, 0.9)', 'rgba(255, 215, 0, 0.9)',
            'rgba(255, 140, 0, 0.9)', 'rgba(255, 20, 147, 0.9)',
            'rgba(147, 112, 219, 0.9)'
        ];
        
        function createRaindrop(progress) {
            const drop = document.createElement('div');
            drop.className = 'raindrop';
            
            drop.style.left = Math.random() * window.innerWidth + 'px';
            drop.style.top = Math.random() * window.innerHeight + 'px';
            
            const color1 = colors[Math.floor(Math.random() * colors.length)];
            const color2 = colors[Math.floor(Math.random() * colors.length)];
            const color3 = colors[Math.floor(Math.random() * colors.length)];
            
            const isTakeover = progress > 0.66;
            
            let baseOpacity = isTakeover 
                ? 0.4 + ((progress - 0.66) / 0.34 * 0.5)
                : 0.15 + (progress * 0.35);
            
            let sizeMultiplier = isTakeover
                ? 1.0 + ((progress - 0.66) / 0.34 * 0.8)
                : 1.5 - (progress * 0.5);
            
            let duration = isTakeover
                ? 6 - ((progress - 0.66) / 0.34 * 2) + Math.random() * 3
                : 10 - (progress * 4) + Math.random() * 4;
            
            let glowIntensity = isTakeover
                ? 30 + (Math.pow((progress - 0.66) / 0.34, 1.5) * 120)
                : (15 + (progress * 50)) * (2.0 - (progress * 1.2));
            
            let baseSize;
            const sizeRoll = Math.random();
            if (isTakeover) {
                baseSize = sizeRoll < 0.2 ? 30 + Math.random() * 15
                         : sizeRoll < 0.5 ? 50 + Math.random() * 30
                         : 60 + Math.random() * 70;
            } else {
                baseSize = sizeRoll < 0.3 ? 20 + Math.random() * 10
                         : sizeRoll < 0.7 ? 40 + Math.random() * 20
                         : 40 + Math.random() * 50;
            }
            
            const finalSize = baseSize * sizeMultiplier;
            drop.style.width = finalSize + 'px';
            drop.style.height = finalSize + 'px';
            
            drop.style.background = `radial-gradient(circle at 40% 40%,
                ${color1.replace('0.9', String(baseOpacity))} 0%,
                ${color2.replace('0.9', String(baseOpacity * 0.7))} 30%,
                ${color3.replace('0.9', String(baseOpacity * 0.4))} 60%,
                transparent 100%)`;
            
            drop.style.boxShadow = `
                0 0 ${glowIntensity}px ${glowIntensity * 0.4}px ${color1},
                0 0 ${glowIntensity * 2}px ${glowIntensity * 0.8}px ${color2}`;
            
            drop.style.animationDuration = duration + 's';
            document.body.appendChild(drop);
            
            setTimeout(() => {
                if (drop.parentNode) drop.parentNode.removeChild(drop);
            }, duration * 1000);
        }
        
        function runTemporalAnimation() {
            if (!startTime || animationRunning) return;
            animationRunning = true;
            
            function animate() {
                if (!startTime || !isConnected) { 
                    animationRunning = false; 
                    return; 
                }
                
                const elapsed = Date.now() - startTime;
                
                if (elapsed >= RAIN_START) {
                    const progress = Math.min((elapsed - RAIN_START) / (SESSION_DURATION - RAIN_START), 1.0);
                    const exponentialGrowth = Math.pow(progress, 2.5);
                    let dropProbability = 0.03 * (1 + exponentialGrowth * 30);
                    
                    if (progress > 0.66) {
                        dropProbability *= 1 + ((progress - 0.66) / 0.34 * 6);
                    }
                    
                    if (Math.random() < dropProbability) {
                        createRaindrop(progress);
                    }
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
    </script>
</body>
</html>
