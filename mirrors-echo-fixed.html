<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mirror's Echo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #000;
            color: rgba(255, 255, 255, 0.9);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Flickering Title */
        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .header h1 {
            font-size: 1.5rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            opacity: 0.8;
            animation: flicker 3s infinite;
        }
        .header p { 
            opacity: 0.5;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }
        
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 0.8;
            }
            20%, 24%, 55% {
                opacity: 0.3;
            }
            22% {
                opacity: 0.5;
                transform: translate(-1px, 0);
            }
        }
        
        /* Connect button at top - flickering */
        .top-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        
        .btn {
            padding: 0.6rem 2rem;
            font-size: 0.85rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.05em;
            transition: all 0.2s;
        }
        .btn:hover:not(:disabled) {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }
        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .btn.flicker-btn {
            animation: btnFlicker 3s infinite;
        }
        
        @keyframes btnFlicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
                border-color: rgba(255, 255, 255, 0.5);
            }
            20%, 24%, 55% {
                opacity: 0.5;
                border-color: rgba(255, 255, 255, 0.2);
            }
            22% {
                opacity: 0.7;
            }
        }
        
        .status-bar {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1.5rem;
        }
        .status-bar .time {
            font-size: 1.2rem;
            opacity: 0.8;
            letter-spacing: 0.1em;
        }
        .status-bar #status {
            font-size: 0.75rem;
            opacity: 0.5;
            margin-top: 0.5rem;
            letter-spacing: 0.02em;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        @media (max-width: 900px) {
            .video-grid { grid-template-columns: 1fr; }
        }
        
        .video-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 1.5rem;
        }
        .video-panel h3 {
            margin-bottom: 1rem;
            font-size: 0.8rem;
            font-weight: 400;
            opacity: 0.6;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .video-box {
            position: relative;
            aspect-ratio: 16/9;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        
        /* Fullscreen/popout button */
        .fullscreen-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.4rem 0.6rem;
            font-size: 0.7rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.05em;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        .video-box:hover .fullscreen-btn {
            opacity: 1;
            animation: btnFlicker 3s infinite;
        }
        .fullscreen-btn:hover {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }
        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.75rem;
            letter-spacing: 0.02em;
        }
        
        /* Raindrop effects */
        .raindrop {
            position: fixed;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: raindrop-fade 8s ease-out forwards;
            will-change: transform, opacity;
        }
        @keyframes raindrop-fade {
            0% { opacity: 0; transform: scale(0.3); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 0.8; }
            100% { opacity: 0; transform: scale(1.2); }
        }
        
        /* Session ended overlay */
        .session-ended {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .session-ended h2 {
            font-size: 1.5rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            opacity: 0.8;
        }
        .session-ended p {
            opacity: 0.5;
            margin-bottom: 2rem;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>THE MIRROR'S ECHO</h1>
            <p>Your camera - Processing - Your reflection transformed</p>
        </div>

        <!-- Connect button at top -->
        <div class="top-controls">
            <button class="btn flicker-btn" id="connectBtn" onclick="connect()">Connect</button>
            <button class="btn" id="disconnectBtn" onclick="disconnect()" style="display:none;">Disconnect</button>
        </div>

        <div class="status-bar">
            <div class="time" id="timer">00:00</div>
            <div id="status">Click Connect to begin</div>
        </div>

        <div class="video-grid">
            <div class="video-panel">
                <h3>Your Camera (Input)</h3>
                <div class="video-box">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-placeholder" id="localPlaceholder">Camera will appear here</div>
                </div>
            </div>

            <div class="video-panel">
                <h3>Processed Output (Your Reflection)</h3>
                <div class="video-box" id="processedBox">
                    <button class="fullscreen-btn" id="fullscreenBtn" onclick="toggleFullscreen()">&#x26F6;</button>
                    <video id="processedVideo" autoplay playsinline></video>
                    <div class="video-placeholder" id="processedPlaceholder">Processed feed will appear here</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <script>
        // TWO ROOMS: Input (publish camera) and Output (receive processed)
        let inputRoom = null;   // claymation-live - we PUBLISH here
        let outputRoom = null;  // processed-output - we SUBSCRIBE here
        let localStream = null;
        let startTime = null;
        let timerInterval = null;

        const localVideo = document.getElementById('localVideo');
        const processedVideo = document.getElementById('processedVideo');
        const localPlaceholder = document.getElementById('localPlaceholder');
        const processedPlaceholder = document.getElementById('processedPlaceholder');
        const statusDiv = document.getElementById('status');
        const timerDiv = document.getElementById('timer');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');

        async function connect() {
            connectBtn.disabled = true;
            connectBtn.classList.remove('flicker-btn');
            updateStatus('Getting camera...');

            try {
                // 1. Get local camera
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });
                localVideo.srcObject = localStream;
                localPlaceholder.style.display = 'none';
                updateStatus('Camera ready. Connecting to rooms...');

                // 2. Connect to INPUT room (publish camera)
                const pubResponse = await fetch('/api/publisher-token?identity=mirror-user-' + Date.now());
                const pubData = await pubResponse.json();

                inputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });
                await inputRoom.connect(pubData.url, pubData.token);

                // Publish camera to input room
                for (const track of localStream.getTracks()) {
                    await inputRoom.localParticipant.publishTrack(track);
                }
                updateStatus('Publishing camera. Connecting to output...');

                // 3. Connect to OUTPUT room (receive processed video)
                const viewResponse = await fetch('/api/processed-viewer-token?identity=mirror-viewer-' + Date.now());
                const viewData = await viewResponse.json();

                outputRoom = new LivekitClient.Room({ adaptiveStream: true, dynacast: true });

                outputRoom.on(LivekitClient.RoomEvent.TrackSubscribed, (track, pub, participant) => {
                    console.log('Received processed track from:', participant.identity);
                    if (track.kind === LivekitClient.Track.Kind.Video) {
                        track.attach(processedVideo);
                        processedPlaceholder.style.display = 'none';
                        updateStatus('Connected - Viewing processed output');
                    }
                });

                outputRoom.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
                    if (track.kind === LivekitClient.Track.Kind.Video) {
                        track.detach(processedVideo);
                        processedPlaceholder.style.display = 'flex';
                        processedPlaceholder.textContent = 'Waiting for processed feed...';
                    }
                });

                await outputRoom.connect(viewData.url, viewData.token);

                // Check for EXISTING participants (OBS might already be publishing)
                outputRoom.remoteParticipants.forEach((participant) => {
                    console.log('Found existing participant:', participant.identity);
                    participant.trackPublications.forEach((pub) => {
                        if (pub.track && pub.track.kind === LivekitClient.Track.Kind.Video) {
                            console.log('Attaching existing video track from:', participant.identity);
                            pub.track.attach(processedVideo);
                            processedPlaceholder.style.display = 'none';
                            updateStatus('Connected - Viewing processed output');
                        }
                    });
                });

                // Start timer
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
                
                // Start temporal animation
                checkAndStartAnimation();

                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
                updateStatus('Connected - Waiting for processed video from OBS...');

            } catch (error) {
                console.error('Connection error:', error);
                updateStatus('Error: ' + error.message);
                connectBtn.disabled = false;
                connectBtn.classList.add('flicker-btn');
            }
        }

        async function disconnect() {
            if (inputRoom) { await inputRoom.disconnect(); inputRoom = null; }
            if (outputRoom) { await outputRoom.disconnect(); outputRoom = null; }
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

            localVideo.srcObject = null;
            processedVideo.srcObject = null;
            localPlaceholder.style.display = 'flex';
            processedPlaceholder.style.display = 'flex';

            connectBtn.style.display = 'inline-block';
            connectBtn.disabled = false;
            connectBtn.classList.add('flicker-btn');
            disconnectBtn.style.display = 'none';
            updateStatus('Disconnected');
        }

        function updateStatus(msg) {
            statusDiv.textContent = msg;
            console.log('[Mirror] ' + msg);
        }

        function updateTimer() {
            if (!startTime) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const min = Math.floor(elapsed / 60);
            const sec = elapsed % 60;
            timerDiv.textContent = `${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
        }

        window.addEventListener('beforeunload', disconnect);
        
        // Fullscreen toggle for processed output
        function toggleFullscreen() {
            const videoBox = document.getElementById('processedBox');
            const video = document.getElementById('processedVideo');
            
            if (!document.fullscreenElement) {
                // Try fullscreen on the video box first, fallback to video
                if (videoBox.requestFullscreen) {
                    videoBox.requestFullscreen();
                } else if (videoBox.webkitRequestFullscreen) {
                    videoBox.webkitRequestFullscreen();
                } else if (video.requestFullscreen) {
                    video.requestFullscreen();
                } else if (video.webkitRequestFullscreen) {
                    video.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }
        
        // === TEMPORAL EFFECTS (7-10 min) ===
        const RAIN_START = 7 * 60 * 1000;  // 7 minutes
        const SESSION_END = 10 * 60 * 1000; // 10 minutes
        let animationRunning = false;
        
        // Colors without neon green
        const colors = [
            'rgba(255, 105, 180, 0.9)', // Hot pink
            'rgba(138, 43, 226, 0.9)', // Blue violet
            'rgba(75, 0, 130, 0.9)',   // Indigo
            'rgba(0, 191, 255, 0.9)',  // Deep sky blue
            'rgba(127, 255, 212, 0.9)', // Aquamarine
            'rgba(255, 215, 0, 0.9)',  // Gold
            'rgba(255, 140, 0, 0.9)',  // Dark orange
            'rgba(255, 20, 147, 0.9)', // Deep pink
            'rgba(147, 112, 219, 0.9)' // Medium purple
        ];
        
        function createRaindrop(progress) {
            const drop = document.createElement('div');
            drop.className = 'raindrop';
            
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            drop.style.left = x + 'px';
            drop.style.top = y + 'px';
            
            const color1 = colors[Math.floor(Math.random() * colors.length)];
            const color2 = colors[Math.floor(Math.random() * colors.length)];
            const color3 = colors[Math.floor(Math.random() * colors.length)];
            
            let baseOpacity = 0.17 + (progress * 0.4);
            baseOpacity = Math.min(baseOpacity, 0.9);
            
            // Size varies: small, medium, large
            let baseSize;
            const sizeRoll = Math.random();
            if (sizeRoll < 0.3) {
                baseSize = 20 + Math.random() * 10;
            } else if (sizeRoll < 0.7) {
                baseSize = 40 + Math.random() * 20;
            } else {
                baseSize = 40 + Math.random() * 50;
            }
            
            const duration = 6 + Math.random() * 4;
            const glowIntensity = 15 + (progress * 50);
            
            drop.style.width = baseSize + 'px';
            drop.style.height = baseSize + 'px';
            
            drop.style.background = `radial-gradient(circle at 40% 40%,
                ${color1.replace('0.9', String(baseOpacity))} 0%,
                ${color2.replace('0.9', String(baseOpacity * 0.7))} 30%,
                ${color3.replace('0.9', String(baseOpacity * 0.4))} 60%,
                transparent 100%)`;
            
            drop.style.boxShadow = `
                ${color1} 0px 0px ${glowIntensity}px,
                ${color2} 0px 0px ${glowIntensity * 2}px,
                ${color1.replace('0.9', '0.3')} 0px 0px ${glowIntensity * 3}px`;
            
            drop.style.animationDuration = duration + 's';
            
            document.body.appendChild(drop);
            
            setTimeout(() => {
                if (drop.parentNode) drop.parentNode.removeChild(drop);
            }, duration * 1000);
        }
        
        function runTemporalAnimation() {
            if (!startTime || animationRunning) return;
            animationRunning = true;
            
            function animate() {
                if (!startTime) { animationRunning = false; return; }
                
                const elapsed = Date.now() - startTime;
                
                // End session at 10 minutes
                if (elapsed >= SESSION_END) {
                    endSession();
                    return;
                }
                
                // Only spawn drops after 7 minutes
                if (elapsed >= RAIN_START) {
                    const rainProgress = (elapsed - RAIN_START) / (SESSION_END - RAIN_START);
                    const progress = Math.min(rainProgress, 1.0);
                    
                    // Exponential growth - starts slow, gets overwhelming
                    const baseRate = 0.03;
                    const exponentialGrowth = Math.pow(progress, 2.5);
                    let dropProbability = baseRate * (1 + exponentialGrowth * 30);
                    
                    // Final surge in last third
                    if (progress > 0.66) {
                        const overtakeProgress = (progress - 0.66) / 0.34;
                        const overtakeMultiplier = 1 + (overtakeProgress * 6);
                        dropProbability *= overtakeMultiplier;
                    }
                    
                    if (Math.random() < dropProbability) {
                        createRaindrop(progress);
                    }
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function endSession() {
            animationRunning = false;
            disconnect();
            
            const overlay = document.createElement('div');
            overlay.className = 'session-ended';
            overlay.innerHTML = `
                <h2>Session Complete</h2>
                <p>Thank you for experiencing The Mirror's Echo</p>
                <button class="btn" onclick="location.reload()">Start New Session</button>
            `;
            document.body.appendChild(overlay);
        }
        
        // Start animation when connected
        function checkAndStartAnimation() {
            if (startTime && !animationRunning) {
                runTemporalAnimation();
            }
        }
    </script>
</body>
</html>
